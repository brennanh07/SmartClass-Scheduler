# settings.py
"""
Django settings for class_scheduler project.

Generated by 'django-admin startproject' using Django 5.0.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path
import environ
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

environ.Env.read_env(os.path.join(BASE_DIR, '.env'))

env = environ.Env()

PYTHONPATH = env('PYTHONPATH')

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = False

ALLOWED_HOSTS = ['http://127.0.0.1:8000/', 'http://localhost:8000/', '127.0.0.1']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'scheduler.apps.SchedulerConfig',
    'scraping.apps.ScrapingConfig',
    'rest_framework',
    'corsheaders',
    'rest_framework_simplejwt',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
]

CORS_ALLOW_ALL_ORIGINS = True

ROOT_URLCONF = 'class_scheduler.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'class_scheduler.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': env('DB_NAME'),
        'USER': env('DB_USER'),
        'PASSWORD': env('DB_PASSWORD'),
        'HOST': env('DB_HOST'),
        'PORT': env('DB_PORT'),
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated', # Default permission class for all views
    ],
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication', # JWT authentication for API
        'rest_framework.authentication.SessionAuthentication', # Session authentication for browsable API
        'rest_framework.authentication.BasicAuthentication' # Basic authentication for browsable API
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', # Default pagination class for all views
    'PAGE_SIZE': 10 # Default page size for pagination
}

# LOGGING = {
#     'version': 1,
#     'disable_existing_loggers': False,
#     'handlers': {
#         'file': {
#             'level': 'DEBUG',
#             'class': 'logging.FileHandler',
#             'filename': 'C:/Users/brenn/VSCode Projects/Class Scheduler Project/backend.0/debug.log',
#         },
#     },
#     'loggers': {
#         'django': {
#             'handlers': ['file'],
#             'level': 'DEBUG',
#             'propagate': True,
#         },
#     },
# }

# urls.py
"""
URL configuration for class_scheduler project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('scheduler.urls')),
]


# admin.py
from django.contrib import admin
from .models import Subject, Professor, Section, SectionTime, User, Preference, Weight, Schedule, ScheduleLog

# Register your models here.
admin.site.register(Subject)

# apps.py
from django.apps import AppConfig


class SchedulerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'scheduler'

# models.py
from django.db import models


class Subject(models.Model):
    abbreviation = models.CharField(max_length=100)
    title = models.CharField(max_length=100)
    
    def __str__(self):
        return (f"{self.abbreviation}: {self.title}")


class Professor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    department = models.CharField(max_length=100)
    rating = models.FloatField()
    difficulty_level = models.FloatField()
    would_take_again = models.FloatField()
    
    def __str__(self):
        return (f"{self.id}: {self.first_name} {self.last_name}")


class Section(models.Model):
    crn = models.IntegerField(primary_key=True)
    course = models.CharField(max_length=100)
    title = models.CharField(max_length=100, default="")
    class_type = models.CharField(max_length=100)
    modality = models.CharField(max_length=100)
    credit_hours = models.CharField(max_length=100)
    capacity = models.CharField(max_length=100)
    # professor = models.ForeignKey("Professor", on_delete=models.CASCADE)
    professor = models.CharField(max_length=100)
    location = models.CharField(max_length=100)
    exam_code = models.CharField(max_length=100)
    
    def __str__(self):
        return (f"{self.crn}: {self.course}")

    
class SectionTime(models.Model):
    crn = models.ForeignKey("Section", on_delete=models.CASCADE)
    days = models.CharField(max_length=100)
    begin_time = models.TimeField()
    end_time = models.TimeField()
    
    def __str__(self):
        return (f"{self.crn}: {self.days} {self.begin_time} - {self.end_time}")
    
    # Define a less-than method to compare SectionTime instances
    def __lt__(self, other):
        if self.begin_time == other.begin_time:
            return self.end_time < other.end_time
        return self.begin_time < other.begin_time
    
    def __gt__(self, other):
        if self.begin_time == other.begin_time:
            return self.end_time > other.end_time
        return self.begin_time > other.begin_time
    
    def __hash__(self):
        return hash((self.crn_id, self.days, self.begin_time, self.end_time))

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return NotImplemented
        return (self.crn_id, self.days, self.begin_time, self.end_time) == \
            (other.crn_id, other.days, other.begin_time, other.end_time)


class User(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    password = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    last_login = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return (f"{self.id}: {self.first_name} {self.last_name}")


class Preference(models.Model):
    user = models.ForeignKey("User", on_delete=models.CASCADE)
    tod_preference = models.CharField(max_length=100)
    dow_preference = models.CharField(max_length=100)


class Weight(models.Model):
    user = models.ForeignKey("User", on_delete=models.CASCADE)
    tod_weight = models.FloatField()
    dow_weight = models.FloatField()
    prof_weight = models.FloatField()


class Schedule(models.Model):
    user = models.ForeignKey("User", on_delete=models.CASCADE)
    crns = models.JSONField()
    created_at = models.DateTimeField(auto_now_add=True)
    score = models.FloatField()


class ScheduleLog(models.Model):
    user = models.ForeignKey("User", on_delete=models.CASCADE)
    crns = models.JSONField()
    score = models.FloatField()
    created_at = models.DateTimeField(auto_now_add=True)

# serializers.py
from rest_framework import serializers
from scheduler.models import Subject, Professor, Section, SectionTime, User, Preference, Weight, Schedule, ScheduleLog

class SubjectSerializer(serializers.ModelSerializer):
    class Meta:
        model = Subject
        fields = '__all__'

class ProfessorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Professor
        fields = '__all__'

class SectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Section
        fields = '__all__'

class SectionTimeSerializer(serializers.ModelSerializer):
    class Meta:
        model = SectionTime
        fields = '__all__'

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = '__all__'

class PreferenceSerializer(serializers.ModelSerializer):
    class Meta:
        model = Preference
        fields = '__all__'

class WeightSerializer(serializers.ModelSerializer):
    class Meta:
        model = Weight
        fields = '__all__'

class ScheduleSerializer(serializers.ModelSerializer):
    class Meta:
        model = Schedule
        fields = '__all__'

class ScheduleLogSerializer(serializers.ModelSerializer):
    class Meta:
        model = ScheduleLog
        fields = '__all__'
        
class BreakSerializer(serializers.Serializer):
    begin_time = serializers.TimeField()
    end_time = serializers.TimeField()
        
class ScheduleInputSerializer(serializers.Serializer):
    courses = serializers.ListField(child=serializers.CharField())
    breaks = serializers.ListField(child=BreakSerializer(), allow_empty=True)
    preferred_days = serializers.ListField(child=serializers.CharField(), allow_empty=True)
    preferred_time = serializers.CharField()
    day_weight = serializers.FloatField()
    time_weight = serializers.FloatField()
    
    
# urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import (
    SubjectViewSet, ProfessorViewSet, SectionViewSet, SectionTimeViewSet, 
    UserViewSet, PreferenceViewSet, WeightViewSet, ScheduleViewSet, 
    ScheduleLogViewSet, GenerateScheduleView
)

# This is the router for the API
router = DefaultRouter()
router.register(r'subjects', SubjectViewSet)
router.register(r'professors', ProfessorViewSet)
router.register(r'sections', SectionViewSet)
router.register(r'section-times', SectionTimeViewSet)
router.register(r'users', UserViewSet)
router.register(r'preferences', PreferenceViewSet)
router.register(r'weights', WeightViewSet)
router.register(r'schedules', ScheduleViewSet)
router.register(r'schedule-logs', ScheduleLogViewSet)

urlpatterns = [
    path('api/v1/', include(router.urls)), # this is the root URL
    path('api/v1/generate-schedules/', GenerateScheduleView.as_view(), name='generate-schedules'), # this is the endpoint for generating schedules
]

# views.py
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from scheduler.models import Subject, Professor, Section, SectionTime, User, Preference, Weight, Schedule, ScheduleLog
from scheduler.serializers import (
    SubjectSerializer, ProfessorSerializer, SectionSerializer, SectionTimeSerializer, UserSerializer, PreferenceSerializer, 
    WeightSerializer, ScheduleSerializer, ScheduleLogSerializer, ScheduleInputSerializer
)

from django.http import JsonResponse
from main import process_schedules
from logging_config import loggers
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt

logger = loggers['views']

class BaseViewSet(viewsets.ModelViewSet):
    permission_classes = [AllowAny]

class SubjectViewSet(viewsets.ModelViewSet):
    queryset = Subject.objects.all()
    serializer_class = SubjectSerializer
    
class ProfessorViewSet(viewsets.ModelViewSet):
    queryset = Professor.objects.all()
    serializer_class = ProfessorSerializer
    
class SectionViewSet(viewsets.ModelViewSet):
    queryset = Section.objects.all()
    serializer_class = SectionSerializer
    
class SectionTimeViewSet(viewsets.ModelViewSet):
    queryset = SectionTime.objects.all()
    serializer_class = SectionTimeSerializer
    
class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    
class PreferenceViewSet(viewsets.ModelViewSet):
    queryset = Preference.objects.all()
    serializer_class = PreferenceSerializer
    
class WeightViewSet(viewsets.ModelViewSet):
    queryset = Weight.objects.all()
    serializer_class = WeightSerializer
    
class ScheduleViewSet(viewsets.ModelViewSet):
    queryset = Schedule.objects.all()
    serializer_class = ScheduleSerializer
    
class ScheduleLogViewSet(viewsets.ModelViewSet):
    queryset = ScheduleLog.objects.all()
    serializer_class = ScheduleLogSerializer
    
@method_decorator(csrf_exempt, name='dispatch')
class GenerateScheduleView(APIView):
    permission_classes = [AllowAny]
    
    def post(self, request, *args, **kwargs):
        logger.info(f"Received schedule generation request: {request.data}")
        serializer = ScheduleInputSerializer(data=request.data)
        
        if serializer.is_valid():
            user_input = serializer.validated_data
            courses = user_input.get("courses")
            breaks = user_input.get("breaks")
            
            
            preferences = {
                "preferred_days": user_input.get("preferred_days"),
                "preferred_time": user_input.get("preferred_time"),
                "day_weight": user_input.get("day_weight"),
                "time_weight": user_input.get("time_weight"),
            }
            
            logger.debug(f"Processed user input: courses={courses}, breaks={breaks}, preferences={preferences}")
            
            try:
                # Generate, score, and format schedules
                generated_schedules = process_schedules(
                    courses=courses,
                    breaks=breaks,
                    preferences=preferences,
                    max_schedules=10
                )
                logger.info(f"Successfully generated {len(generated_schedules)} schedules")
                return JsonResponse({"schedules": generated_schedules}, status=status.HTTP_200_OK)
            
            except Exception as e:
                logger.error(f"Error generating schedules: {str(e)}")
                logger.exception("Full traceback:")
                return Response({"error": f"Failed to generate schedules: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        logger.warning(f"Invalid input data: {serializer.errors}")
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

# manage.py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys
from pathlib import Path

sys.path.append(str(Path(__file__).resolve().parent / 'scheduler'))


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'class_scheduler.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

# fetch_sections.py
import django
import os
from logging_config import loggers

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'class_scheduler.settings')
django.setup()

from scheduler.models import Section, SectionTime

logger = loggers['fetch_sections']

class SectionFetcher:
    def __init__(self, courses):
        self.courses = courses
        self.section_dict = {}
        self.section_time_dict = {}
        
    def fetch_sections(self):
        """
        Fetch all sections and their corresponding times for the given courses using batch fetching.
        
        Args:
            courses (list): A list of courses to fetch sections for.
            
        Returns:
            section_dict (dict): Dictionary mapping CRNs to Section objects.
            section_time_dict (dict): Dictionary mapping CRNs to lists of SectionTime objects.
        """
        logger.info(f"Fetching sections for courses: {self.courses}")
        sections = Section.objects.filter(course__in=self.courses).prefetch_related('sectiontime_set')
        logger.debug(f"Found {len(sections)} sections")
        
        self.section_dict = {section.crn: section for section in sections}
        self.section_time_dict = {section.crn: list(section.sectiontime_set.all()) for section in sections}
        
        logger.debug(f"Fetched sections: {self.section_dict}")
        logger.debug(f"Fetched section times: {self.section_time_dict}")
        
        if not self.section_dict:
            logger.warning(f"No sections found for courses: {self.courses}")
        
        return self.section_dict, self.section_time_dict
    
    
# schedule_generator.py
from collections import defaultdict
import heapq
from typing import List, Dict, Tuple, Any
from schedule_scoring import ScheduleScorer
import threading
import time


class ScheduleHeapElement:
    def __init__(self, score: float, schedule: Dict[str, List[Any]]):
        self.score = score
        self.schedule = schedule

    def __lt__(self, other):
        return self.score > other.score

    def __eq__(self, other):
        return self.score == other.score 


class ScheduleGenerator:
    def __init__(
        self, section_dict, section_time_dict, breaks, preferences, max_schedules=10
    ):
        self.section_dict = section_dict
        self.section_time_dict = section_time_dict
        self.breaks = breaks
        self.preferences = preferences
        self.max_schedules = max_schedules
        self.scorer = ScheduleScorer(self.preferences)

        # Group section times by course
        self.course_sections = defaultdict(list)
        for crn, section in section_dict.items():
            self.course_sections[section.course].append((crn, section_time_dict[crn]))

        # Sort courses by the number of sections (ascending)
        self.sorted_courses = sorted(
            self.course_sections.keys(), key=lambda c: len(self.course_sections[c])
        )

    def generate_schedules(self):
        heap = []
        thread = threading.Thread(target=self._dfs, args=(0, {}, [], heap))
        thread.start()
        thread.join(timeout=90) # Timeout after 1 minute 30 seconds
        if thread.is_alive():
            print("Schedule generation timed out")
            return ["timeout"]

        return [
            (element.score, element.schedule) for element in sorted(heap)
        ]

    def _dfs(
        self,
        course_index: int,
        current_schedule: Dict[str, List[Any]],
        flat_schedule: List[Any],
        heap: List[ScheduleHeapElement],
    ):
        if course_index == len(self.sorted_courses):
            score = self.scorer.score_schedule(
                tuple(flat_schedule)
            )  # Convert list to tuple
            element = ScheduleHeapElement(score, current_schedule.copy())
            if len(heap) < self.max_schedules:
                heapq.heappush(heap, element)
            elif score > heap[0].score:
                heapq.heapreplace(heap, element)
            return

        course = self.sorted_courses[course_index]
        for crn, times in self.course_sections[course]:
            if self._is_valid_addition(flat_schedule, times):
                current_schedule[crn] = times
                self._dfs(
                    course_index + 1, current_schedule, flat_schedule + times, heap
                )
                current_schedule.pop(crn)

    def _is_valid_addition(
        self, current_schedule: List[Any], new_times: List[Any]
    ) -> bool:
        for new_time in new_times:
            # Check for conflicts with existing times
            for existing_time in current_schedule:
                if self._check_conflict(new_time, existing_time):
                    return False

            # Check for conflicts with breaks
            for break_time in self.breaks:
                if (
                    new_time.begin_time >= break_time["begin_time"]
                    and new_time.begin_time <= break_time["end_time"]
                ):
                    return False
        return True

    @staticmethod
    def _check_conflict(time1: Any, time2: Any) -> bool:
        return (
            set(time1.days) & set(time2.days)
            and time1.end_time > time2.begin_time
            and time1.begin_time < time2.end_time
        )

# schedule_scoring.py
import datetime
from collections import defaultdict
import logging
from itertools import groupby
from operator import attrgetter
from functools import lru_cache

# Setup logging
logging.basicConfig(level=logging.DEBUG, filename='scheduler.log', filemode='w')

class ScheduleScorer:
    def __init__(self, preferences):
        self.preferences = preferences
        self.preferred_days = tuple(preferences['preferred_days'])
        
    @lru_cache(maxsize=1024)
    def score_schedule(self, schedule):
        return sum(self.score_section_time(section_time) for section_time in schedule)
    
    @lru_cache(maxsize=1024)
    def score_section_time(self, section_time):
        if section_time.begin_time == datetime.time(0, 0):
            day_score = 1
            time_score = 1
        else:
            matching_days = len(set(section_time.days) & set(self.preferred_days))
            day_score = matching_days / len(section_time.days)
            time_score = self.score_time(section_time.begin_time)
        
        return (day_score * self.preferences['day_weight']) + (time_score * self.preferences['time_weight'])
    
    @lru_cache(maxsize=128)
    def score_time(self, begin_time):
        preferred_time = self.preferences['preferred_time']
        
        time_ranges = {
            'morning': (datetime.time(8, 0), datetime.time(12, 0)),
            'afternoon': (datetime.time(12, 0), datetime.time(16, 0)),
            'evening': (datetime.time(16, 0), datetime.time(20, 0)),
        }
        
        if preferred_time not in time_ranges:
            return 0
        
        preferred_start, preferred_end = time_ranges[preferred_time]
        
        if begin_time < preferred_start:
            score = max(0, 1 - (preferred_start.hour - begin_time.hour + (preferred_start.minute - begin_time.minute) / 60) / 4)
        elif preferred_start <= begin_time <= preferred_end:
            score = 1
        else:
            score = max(0, 1 - (begin_time.hour - preferred_end.hour + (begin_time.minute - preferred_end.minute) / 60) / 4)
        
        return score


# schedule_formatter.py
from collections import defaultdict
from logging_config import loggers

logger = loggers['schedule_formatter']

class ScheduleFormatter:
    def __init__(self, date_format="%I:%M %p"):
        """
        Initialize the ScheduleFormatter object with optional formatting settings.
        
        Args:
            date_format (str): The format string to use for displaying dates and times
        """
        self.date_format = date_format
        
    def format_schedule(self, schedule):
        day_schedule = defaultdict(list)
        crn_dict = {}
        
        for crn, section_times in schedule.items():
            for section_time in section_times:
                day_name = section_time.days
                
                if isinstance(day_name, float):
                    day_name = str(int(day_name))
                elif isinstance(day_name, str):
                    day_name = day_name.capitalize()
                else:
                    day_name = "Unknown"
                
                try:
                    class_info = f"{section_time.crn.course}: {section_time.begin_time.strftime(self.date_format)} - {section_time.end_time.strftime(self.date_format)}"
                except AttributeError as e:
                    logger.error(f"Error formatting class info: {e}")
                    class_info = "Error: Unable to format class info"
                
                day_schedule[day_name].append((section_time.begin_time, class_info))
                
                if hasattr(section_time.crn, 'course'):
                    if section_time.crn.course not in crn_dict:
                        crn_dict[section_time.crn.course] = section_time.crn.crn
                else:
                    logger.error(f"section_time.crn does not have 'course' attribute: {section_time.crn}")

        ordered_schedule = {} 
        for day in ["M", "T", "W", "R", "F", "S", "U"]:
            if day in day_schedule:
                ordered_schedule[day] = [class_info for _, class_info in sorted(day_schedule[day])]
            elif "Online" in day_schedule or "Arr" in day_schedule:
                ordered_schedule["Online/ARR"] = [class_info for _, class_info in sorted(day_schedule.get("Online", []) + day_schedule.get("Arr", []))]
            else:
                ordered_schedule[day] = []
            
        return {
            "days": ordered_schedule,
            "crns": crn_dict
        }
        
    def print_ranked_schedules(self, top_schedules, top_n=10):
        formatted_schedules_list = []
        
        for i, (score, schedule) in enumerate(top_schedules[:top_n], 1):
            try:
                formatted_schedule_data = self.format_schedule(schedule)
                formatted_schedule = {
                    "name": f"Schedule {i}",
                    "score": score,
                    "days": formatted_schedule_data["days"],
                    "crns": formatted_schedule_data["crns"]
                }
                formatted_schedules_list.append(formatted_schedule)
            except Exception as e:
                logger.error(f"Error formatting schedule {i}: {e}")
        
        return formatted_schedules_list
    
# main.py
from fetch_sections import SectionFetcher
from schedule_formatter import ScheduleFormatter
from logging_config import loggers
from schedule_generator import ScheduleGenerator

logger = loggers['main']

def process_schedules(courses, breaks, preferences, max_schedules=10):
    """
    Main function to generate and format schedules for the given list of courses and input.
    
    Args:
        courses (list): A list of course codes to generate schedules for
        breaks (list): A list of break times to exclude from schedules
        preferences (dict): A dictionary of user preferences for scheduling
        max_schedules (int): The maximum number of schedules to return
        
    Returns:
        list: A list of formatted schedules as dictionaries with names, days, and CRNs
    """
    logger.info(f"Processing schedules for courses: {courses}")
    logger.debug(f"Preferences: {preferences}")
    logger.debug(f"Breaks: {breaks}")
    
    # Fetch sections from the database
    section_fetcher = SectionFetcher(courses)
    section_dict, section_time_dict = section_fetcher.fetch_sections()
    
    if not section_dict:
        logger.warning("No sections found. Aborting schedule generation.")
        return []
    
    # Generate and score valid schedules dynamically
    logger.info("Generating schedules")
    schedule_generator = ScheduleGenerator(section_dict, section_time_dict, breaks, preferences, max_schedules)
    top_schedules = schedule_generator.generate_schedules()
    
    logger.info(f"Generated {len(top_schedules)} schedules")
    
    # Format the top N schedules for display
    formatter = ScheduleFormatter(date_format="%I:%M %p")
    formatted_schedules = formatter.print_ranked_schedules(top_schedules, top_n=max_schedules)
    
    logger.info("Schedule processing complete")
    return formatted_schedules
